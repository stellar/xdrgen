module Xdrgen
  module Generators
    class Elixir < Xdrgen::Generators::Base
      MAX_INT = (2**31) - 1

      def generate
        @constants = Hash.new

        render_consts_definitions(@top)
        render_definitions(@top)
        render_base_classes
      end

      private
      def render_definitions(node)
        node.definitions.each{|n| render_definition n }
        node.namespaces.each{|n| render_definitions n }
      end

      def render_consts_definitions(node)
        node.definitions.each{|n| render_consts n }
        node.namespaces.each{|n| render_consts_definitions n }
      end

      def render_nested_definitions(defn)
        return unless defn.respond_to? :nested_definitions
        defn.nested_definitions.each{|ndefn| render_definition ndefn}
      end

      def render_definition(defn)
        render_nested_definitions(defn)

        case defn
        when AST::Definitions::Struct ;
          render_struct defn
        when AST::Definitions::Enum ;
          render_enum defn
        when AST::Definitions::Union ;
          render_union defn
        when AST::Definitions::Typedef ;
          render_typedef(defn, false)
        end
      end

      def render_consts(defn)
        case defn
        when AST::Definitions::Const;
          render_const defn
        end
      end

      def render_moduledoc(out, type)
        out.puts <<-EOS.strip_heredoc
          @moduledoc """
          Automatically generated by xdrgen
          DO NOT EDIT or your changes may be overwritten

          Target implementation: elixir_xdr at https://hex.pm/packages/elixir_xdr

          Representation of Stellar `#{type.upcase_first}` type.
          """
        EOS
        out.break
        out.puts "@behaviour XDR.Declaration\n\n"
      end

      def render_define_block(out, module_name)
        out.puts "defmodule #{@namespace}.#{module_name.upcase_first} do"
        out.indent do
          render_moduledoc(out, module_name)
        end
        yield
      ensure
        out.puts "end"
        out.break
      end

      def render_typedef(typedef, is_struct)
        build_typedef(typedef, is_struct)
      end

      def render_const(const)
        @constants["#{const.name.underscore.downcase}"] = const.value
      end

      def render_other_type(type)
        begin
          type_name_camelize = type.name.camelize
          declaration_type = type.declaration.type
          sub_type = declaration_type.sub_type
          number = type_reference(type, type_name_camelize).scan(/\d+/).first

          case sub_type
          when :optional
            base_type = type_string(declaration_type)
            name = type_reference(type, type_name_camelize)
            build_optional_typedef(type, base_type, name)
          when :var_array, :array
            base_type = type_string(declaration_type)
            name = type_reference(type, type_name_camelize)
            if sub_type == :var_array
              is_named, size = declaration_type.array_size
              size = get_size(size, is_named, true)
              length_nil = declaration_type.decl.resolved_size.nil?
              name = "#{name}#{size unless length_nil}"
              build_list_typedef(name, base_type, "VariableArray", declaration_type)
            else
              build_list_typedef(name, base_type, "FixedArray", declaration_type)
            end
          else

            unless number.nil?
              render_typedef(type, true)
            end
          end
        rescue => exception
        end
      end

      def render_struct(struct)
        struct_name = name struct
        file_name = "#{struct_name.underscore}.ex"
        out = @output.open(file_name)

        render_define_block(out, struct_name) do
          out.indent do
            out.puts "alias #{@namespace}.{\n"
            out.indent do
              alias_list = []
              struct.members.each do |m|
                name = type_reference m, m.name.camelize
                unless alias_list.include?(name)
                  if m.declaration.type.sub_type == :var_array
                    name = add_size_to_name(m, name)
                  end
                  alias_list << name
                  render_other_type(m)
                end
              end

              alias_list.each_with_index do |m, i|
                out.puts "#{m}#{comma_unless_last(i, alias_list)}"
              end
            end
            out.puts "}\n\n"

            out.puts "@struct_spec XDR.Struct.new("
            out.indent do
              struct.members.each_with_index do |m, i|
                module_name = type_reference m, m.name.camelize
                if m.declaration.type.sub_type == :var_array
                  module_name = add_size_to_name(m, module_name)
                end
                out.puts "#{m.name.underscore.downcase}: #{module_name}#{comma_unless_last(i, struct.members)}"
              end
            end
            out.puts ")\n\n"

            struct.members.each_with_index do |m, i|
              module_name = type_reference m, m.name.camelize
              if m.declaration.type.sub_type == :var_array
                module_name = add_size_to_name(m, module_name)
              end
              out.puts "@type type_#{m.name.underscore.downcase} :: #{module_name}.t()"
            end
            out.puts "\n"

            types = "@type t :: %__MODULE__{"
              struct.members.each_with_index do |m, i|
              types += "#{m.name.underscore.downcase}: type_#{m.name.underscore.downcase}()#{comma_and_space_unless_last(i, struct.members)}"
              end
            types += "}\n\n"
            out.puts types

            def_struct = "defstruct ["
              struct.members.each_with_index do |m, i|
              def_struct += ":#{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
              end
            def_struct += "]\n\n"
            out.puts def_struct

            spec = "@spec new("
              struct.members.each_with_index do |m, i|
              spec += "#{m.name.underscore.downcase} :: type_#{m.name.underscore.downcase}()#{comma_and_space_unless_last(i, struct.members)}"
              end
            spec += ") :: t()\n"
            out.puts spec

            out.puts "def new("
            out.indent do
              struct.members.each_with_index do |m, i|
                module_name = type_reference m, m.name.camelize
                if m.declaration.type.sub_type == :var_array
                  module_name = add_size_to_name(m, module_name)
                end
                out.puts "%#{module_name}{} = #{m.name.underscore.downcase}#{comma_unless_last(i, struct.members)}"
              end
            end
            out.puts "),\n"
            function = "do: %__MODULE__{"
              struct.members.each_with_index do |m, i|
              function += "#{m.name.underscore.downcase}: #{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
              end
            function += "}\n\n"
            out.puts function

            out.puts "@impl true\n"
            impl = "def encode_xdr(%__MODULE__{"
              struct.members.each_with_index do |m, i|
              impl += "#{m.name.underscore.downcase}: #{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
              end
            impl += "}) do\n"
            out.puts impl
            args = "["
            out.indent do
              struct.members.each_with_index do |m, i|
                args += "#{m.name.underscore.downcase}: #{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
              end
              args += "]\n"
              out.puts args
              out.puts "|> XDR.Struct.new()"
              out.puts "|> XDR.Struct.encode_xdr()"
            end
            out.puts "end\n\n"

            out.puts "@impl true\n"
            impl = "def encode_xdr!(%__MODULE__{"
              struct.members.each_with_index do |m, i|
              impl += "#{m.name.underscore.downcase}: #{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
              end
            impl += "}) do\n"
            out.puts impl
            args = "["
            out.indent do
              struct.members.each_with_index do |m, i|
                args += "#{m.name.underscore.downcase}: #{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
              end
              args += "]\n"
              out.puts args
              out.puts "|> XDR.Struct.new()"
              out.puts "|> XDR.Struct.encode_xdr!()"
            end
            out.puts "end\n\n"

            out.puts "@impl true\n"
            out.puts "def decode_xdr(bytes, struct \\\\ @struct_spec)\n\n"

            out.puts "def decode_xdr(bytes, struct) do"
            out.indent do
              out.puts "case XDR.Struct.decode_xdr(bytes, struct) do"
                out.indent do
                  comp = "{:ok, {%XDR.Struct{components: ["
                    struct.members.each_with_index do |m, i|
                    comp += "#{m.name.underscore.downcase}: #{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
                    end
                  comp += "]}, rest}} ->\n"
                  out.puts comp
                  out.indent do
                    new_comp = "{:ok, {new("
                    struct.members.each_with_index do |m, i|
                      new_comp += "#{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
                    end
                    new_comp += "), rest}}"
                    out.puts new_comp
                  end
                  out.puts "error -> error"
                end
              out.puts "end"
            end
            out.puts "end\n\n"

            out.puts "@impl true\n"
            out.puts "def decode_xdr!(bytes, struct \\\\ @struct_spec)\n\n"

            out.puts "def decode_xdr!(bytes, struct) do"
            out.indent do
              comp = "{%XDR.Struct{components: ["
                struct.members.each_with_index do |m, i|
                comp += "#{m.name.underscore.downcase}: #{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
                end
              comp += "]}, rest} =\n"
              out.puts comp
              out.indent do
                out.puts "XDR.Struct.decode_xdr!(bytes, struct)"
              end
              new_comp = "{new("
                struct.members.each_with_index do |m, i|
                new_comp += "#{m.name.underscore.downcase}#{comma_and_space_unless_last(i, struct.members)}"
                end
              new_comp += "), rest}"
              out.puts new_comp
            end
            out.puts "end"
          end
        end
        out.close
      end

      def render_enum(enum)
        enum_name = name enum
        file_name = "#{enum_name.underscore}.ex"
        out = @output.open(file_name)

        render_define_block(out, enum_name) do
          out.indent do
            out.puts "@declarations [\n"
            out.indent do
              enum.members.each_with_index do |m, i|
                out.puts "#{m.name}: #{m.value}#{comma_unless_last(i, enum.members)}"
              end
            end
            out.puts "]\n\n"

            out.puts "@enum_spec %XDR.Enum{declarations: @declarations, identifier: nil}\n\n"

            out.puts "@type t :: %__MODULE__{identifier: atom()}\n\n"

            out.puts "defstruct [:identifier]\n\n"

            out.puts "@spec new(type :: atom()) :: t()\n"
            out.puts "def new(type \\\\ :#{enum.members.first.name}), do: %__MODULE__{identifier: type}\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr(%__MODULE__{identifier: type}) do\n"
            out.indent do
              out.puts "@declarations\n"
              out.puts "|> XDR.Enum.new(type)\n"
              out.puts "|> XDR.Enum.encode_xdr()\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr!(%__MODULE__{identifier: type}) do\n"
            out.indent do
              out.puts "@declarations\n"
              out.puts "|> XDR.Enum.new(type)\n"
              out.puts "|> XDR.Enum.encode_xdr!()\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr(bytes, spec \\\\ @enum_spec)\n\n"

            out.puts "def decode_xdr(bytes, spec) do\n"
            out.indent do
              out.puts "case XDR.Enum.decode_xdr(bytes, spec) do\n"
              out.indent do
                out.puts "{:ok, {%XDR.Enum{identifier: type}, rest}} -> {:ok, {new(type), rest}}\n"
                out.puts "error -> error\n"
              end
              out.puts "end\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr!(bytes, spec \\\\ @enum_spec)\n\n"

            out.puts "def decode_xdr!(bytes, spec) do\n"
            out.indent do
              out.puts "{%XDR.Enum{identifier: type}, rest} = XDR.Enum.decode_xdr!(bytes, spec)\n"
              out.puts "{new(type), rest}\n"
            end
            out.puts "end\n"
          end
        end
      end

      def render_union(union)
        union_name = name union
        union_name_camelize = union.name.camelize
        union_discriminant = union.discriminant
        is_number_type = is_number_type?(union)

        file_name = "#{union_name.underscore}.ex"
        out = @output.open(file_name)

        render_define_block(out, union_name) do
          out.indent do
            out.puts "alias #{@namespace}.{\n"
            out.indent do
              out.puts "#{type_reference union_discriminant, union_name_camelize},"
              alias_list = []
              union.arms.each do |m|
                name = m.void? ? "Void" : "#{type_reference m, m.name.camelize}"
                unless alias_list.include?(name)
                  unless m.void?
                    if m.declaration.type.sub_type == :var_array
                      name = add_size_to_name(m, name)
                    end
                  end
                  alias_list << name
                  render_other_type(m)
                end
              end

              alias_list.each_with_index do |m, i|
                out.puts "#{m}#{comma_unless_last(i, alias_list)}"
              end
            end
            out.puts "}\n\n"

            out.puts "@arms #{is_number_type ? "%{" : "["}"
            out.indent do
              union.normal_arms.each_with_index do |arm, i|
                arm_name = arm.void? ? "Void" : "#{type_reference arm, arm.name.camelize}"
                unless arm.void?
                  if arm.declaration.type.sub_type == :var_array
                    arm_name = add_size_to_name(arm, arm_name)
                  end
                end
                arm.cases.each_with_index do |acase, o|
                  switch = if acase.value.is_a?(AST::Identifier)
                    "#{acase.value.text_value}:"
                  else
                    "#{acase.value.text_value} =>"
                  end
                  out.puts "#{switch} #{arm_name}#{(union.arms.count <= (i + 1)) && ((o + 1) >= arm.cases.count) ? "" : ","}"
                end
              end

              if union.default_arm.present?
                out.puts "default: #{type_reference union.default_arm, union.default_arm.name.camelize}"
              end
            end
            out.puts "#{is_number_type ? "}" : "]"}\n\n"

            out.puts "@type value ::"
            out.indent(4) do
              type_list = ""
              union.arms.each_with_index do |m, i|
                name = m.void? ? "Void" : "#{type_reference m, m.name.camelize}"
                unless m.void?
                  if m.declaration.type.sub_type == :var_array
                    name = add_size_to_name(m, name)
                  end
                end
                if i == 0
                  type_list += "#{name}.t()\n"
                else
                  unless type_list.include?(name)
                    type_list += "| #{name}.t()\n"
                  end
                end
              end
              out.puts type_list

              if union.default_arm.present?
                out.puts "| any()"
              end

            end
            out.puts "\n"

            out.puts "@type t :: %__MODULE__{value: value(), type: #{type_reference union_discriminant, union_name_camelize}.t()}\n\n"

            out.puts "defstruct [:value, :type]\n\n"

            out.puts "@spec new(value :: value(), type :: #{type_reference union_discriminant, union_name_camelize}.t()) :: t()\n"
            out.puts "def new(value, %#{type_reference union_discriminant, union_name_camelize}{} = type), do: %__MODULE__{value: value, type: type}\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr(%__MODULE__{value: value, type: type}) do\n"
            out.indent do
              out.puts "type\n"
              out.puts "|> XDR.Union.new(@arms, value)\n"
              out.puts "|> XDR.Union.encode_xdr()\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr!(%__MODULE__{value: value, type: type}) do\n"
            out.indent do
              out.puts "type\n"
              out.puts "|> XDR.Union.new(@arms, value)\n"
              out.puts "|> XDR.Union.encode_xdr!()\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr(bytes, spec \\\\ union_spec())\n\n"

            out.puts "def decode_xdr(bytes, spec) do\n"
            out.indent do
              out.puts "case XDR.Union.decode_xdr(bytes, spec) do\n"
              out.indent do
                out.puts "{:ok, {{type, value}, rest}} -> {:ok, {new(value, type), rest}}\n"
                out.puts "error -> error\n"
              end
              out.puts "end\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr!(bytes, spec \\\\ union_spec())\n\n"

            out.puts "def decode_xdr!(bytes, spec) do\n"
            out.indent do
              out.puts "{{type, value}, rest} = XDR.Union.decode_xdr!(bytes, spec)\n"
              out.puts "{new(value, type), rest}\n"
            end
            out.puts "end\n\n"

            out.puts "@spec union_spec() :: XDR.Union.t()"
            out.puts "defp union_spec do"
            out.indent do
              out.puts "#{is_number_type ? 0 : "nil"}\n"
              out.puts "|> #{type_reference union_discriminant, union_name_camelize}.new()\n"
              out.puts "|> XDR.Union.new(@arms)\n"
            end
            out.puts "end\n"
          end
        end
      end

      private
      def add_size_to_name(member, name)
        is_named, size = member.declaration.type.array_size
        size = get_size(size, is_named, true)
        length_nil = member.declaration.type.decl.resolved_size.nil?
        "#{name}#{size unless length_nil}"
      end

      def get_size(size, is_named = false, is_var_array_type = false)
        if size
          if is_var_array_type
            is_named ? @constants["#{size.underscore.downcase}"] : (size || MAX_INT)
          else
            size.scan(/\D/).any? ? @constants["#{size.underscore.downcase}"] : size
          end
        end
      end

      def render_base_classes
        file_name = "base.ex"
        out = @output.open(file_name)
        base_py_content = IO.read(__dir__ + "/elixir/base.ex")
        new_base_file = base_py_content.gsub("defmodule ", "defmodule #{@namespace}.")
        out.puts new_base_file
        out.close
      end

      def is_number_type?(union)
        value = false
        union.normal_arms.each do |arm|
          arm.cases.each do |acase|
            value = if acase.value.is_a?(AST::Identifier)
              false
            else
              true
            end
          end
        end
        value
      end

      def type_reference(decl, container_name)
        type_hint = type_string decl.type

        if type_hint == container_name
          type_hint = "#{type_hint}"
        end

        case decl.type.sub_type
          when :optional
            "Optional#{type_hint}"
          when :var_array
            "#{type_hint}List"
          when :array
            "#{type_hint}FixedList"
          else
            type_hint
        end
      end

      def comma_unless_last(index, collection)
        if index + 1 >= collection.length
          ""
        else
          ","
        end
      end

      def comma_and_space_unless_last(index, collection)
        if index + 1 >= collection.length
          ""
        else
          ", "
        end
      end

      def type_string(type)
        case type
          when AST::Typespecs::Simple
            "#{name type}"
          when AST::Definitions::Base
            "#{name type}"
          when AST::Concerns::NestedDefinition
            "#{name type}"
          when AST::Typespecs::Bool
            "Bool"
          when AST::Typespecs::Double
            "DoubleFloat"
          when AST::Typespecs::Float
            "Float"
          when AST::Typespecs::Hyper
            "HyperInt"
          when AST::Typespecs::Int
            "Int"
          when AST::Typespecs::Opaque
            if type.fixed?
              "Opaque#{get_size(type.size)}"
            else
              type.size ? "VariableOpaque#{get_size(type.size)}" : "VariableOpaque"
            end
          when AST::Typespecs::Quadruple
            raise "no quadruple support in elixir"
          when AST::Typespecs::String
            "String#{get_size(type.size)}"
          when AST::Typespecs::UnsignedHyper
            "HyperUInt"
          when AST::Typespecs::UnsignedInt
            "UInt"
          else
            raise "Unknown reference type: #{type.class.name}, #{type.class.ancestors}"
        end
      end

      def build_simple_typedef(typedef, type, module_name, is_struct)
        unless is_struct
          attribute = module_name.underscore.downcase
          file_name = "#{attribute}.ex"
          out = @output.open(file_name)

          render_define_block(out, module_name) do 
            out.indent do
              out.puts "alias #{@namespace}.#{type}\n\n"

              out.puts "@type t :: %__MODULE__{#{attribute}: #{type}.t()}\n\n"

              out.puts "defstruct [:#{attribute}]\n\n"

              out.puts "@spec new(#{attribute} :: #{type}.t()) :: t()\n"
              out.puts "def new(%#{type}{} = #{attribute}), do: %__MODULE__{#{attribute}: #{attribute}}\n\n"

              out.puts "@impl true"
              out.puts "def encode_xdr(%__MODULE__{#{attribute}: #{attribute}}) do\n"
              out.indent do
                out.puts "#{type}.encode_xdr(#{attribute})\n"
              end
              out.puts "end\n\n"

              out.puts "@impl true"
              out.puts "def encode_xdr!(%__MODULE__{#{attribute}: #{attribute}}) do\n"
              out.indent do
                out.puts "#{type}.encode_xdr!(#{attribute})\n"
              end
              out.puts "end\n\n"

              out.puts "@impl true"
              out.puts "def decode_xdr(bytes, term \\\\ nil)\n\n"

              out.puts "def decode_xdr(bytes, _term) do\n"
              out.indent do
                out.puts "case #{type}.decode_xdr(bytes) do\n"
                out.indent do
                  out.puts "{:ok, {%#{type}{} = #{attribute}, rest}} -> {:ok, {new(#{attribute}), rest}}\n"
                  out.puts "error -> error\n"
                end
                out.puts "end\n"
              end
              out.puts "end\n\n"

              out.puts "@impl true"
              out.puts "def decode_xdr!(bytes, term \\\\ nil)\n\n"

              out.puts "def decode_xdr!(bytes, _term) do\n"
              out.indent do
                out.puts "{%#{type}{} = #{attribute}, rest} = #{type}.decode_xdr!(bytes)\n"
                out.puts "{new(#{attribute}), rest}\n"
              end
              out.puts "end\n"
            end
          end
          out.close
        end
      end

      def build_number_typedef(typedef, number_type, type, attribute)
        file_name = "#{typedef.name.underscore.downcase}.ex"
        out = @output.open(file_name)

        render_define_block(out, typedef.name) do 
          out.indent do
            out.puts "@type t :: %__MODULE__{#{attribute}: #{number_type}()}\n\n"

            out.puts "defstruct [:#{attribute}]\n\n"

            out.puts "@spec new(value :: #{number_type}()) :: t()\n"
            out.puts "def new(value), do: %__MODULE__{#{attribute}: value}\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr(%__MODULE__{#{attribute}: value}) do\n"
            out.indent do
              out.puts "XDR.#{type}.encode_xdr(%XDR.#{type}{datum: value})\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr!(%__MODULE__{#{attribute}: value}) do\n"
            out.indent do
              out.puts "XDR.#{type}.encode_xdr!(%XDR.#{type}{datum: value})\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr(bytes, term \\\\ nil)\n\n"

            out.puts "def decode_xdr(bytes, _term) do\n"
            out.indent do
              out.puts "case XDR.#{type}.decode_xdr(bytes) do\n"
              out.indent do
                out.puts "{:ok, {%XDR.#{type}{datum: value}, rest}} -> {:ok, {new(value), rest}}\n"
                out.puts "error -> error\n"
              end
              out.puts "end\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr!(bytes, term \\\\ nil)\n\n"

            out.puts "def decode_xdr!(bytes, _term) do\n"
            out.indent do
              out.puts "{%XDR.#{type}{datum: value}, rest} = XDR.#{type}.decode_xdr!(bytes)\n"
              out.puts "{new(value), rest}\n"
            end
            out.puts "end\n"
          end
        end
        out.close
      end

      def build_bool_typedef(typedef, number_type, type, attribute)
        file_name = "#{typedef.name.downcase.underscore}.ex"
        out = @output.open(file_name)

        render_define_block(out, typedef.name.downcase) do 
          out.indent do
            out.puts "@type t :: %__MODULE__{#{attribute}: #{number_type}()}\n\n"

            out.puts "defstruct [:#{attribute}]\n\n"

            out.puts "@spec new(value :: #{number_type}()) :: t()\n"
            out.puts "def new(value), do: %__MODULE__{#{attribute}: value}\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr(%__MODULE__{#{attribute}: value}) do\n"
            out.indent do
              out.puts "XDR.#{type}.encode_xdr(%XDR.#{type}{identifier: value})\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr!(%__MODULE__{#{attribute}: value}) do\n"
            out.indent do
              out.puts "XDR.#{type}.encode_xdr!(%XDR.#{type}{identifier: value})\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr(bytes, term \\\\ nil)\n\n"

            out.puts "def decode_xdr(bytes, _term) do\n"
            out.indent do
              out.puts "case XDR.#{type}.decode_xdr(bytes) do\n"
              out.indent do
                out.puts "{:ok, {%XDR.#{type}{identifier: value}, rest}} -> {:ok, {new(value), rest}}\n"
                out.puts "error -> error\n"
              end
              out.puts "end\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr!(bytes, term \\\\ nil)\n\n"

            out.puts "def decode_xdr!(bytes, _term) do\n"
            out.indent do
              out.puts "{%XDR.#{type}{identifier: value}, rest} = XDR.#{type}.decode_xdr!(bytes)\n"
              out.puts "{new(value), rest}\n"
            end
            out.puts "end\n"
          end
        end
        out.close
      end

      def build_string_typedef(typedef, is_struct)
        name = is_struct ? type_string(typedef.declaration.type) : typedef.name

        file_name = "#{name.underscore.downcase}.ex"
        out = @output.open(file_name)

        render_define_block(out, name) do 
          out.indent do
            out.puts "@type t :: %__MODULE__{value: String.t()}\n\n"

            out.puts "defstruct [:value]\n\n"

            unless typedef.declaration.type.size.nil?
              out.puts "@max_length #{get_size(typedef.declaration.type.size)}\n\n"
            end

            out.puts "@spec new(value :: String.t()) :: t()\n"
            out.puts "def new(value), do: %__MODULE__{value: value}\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr(%__MODULE__{value: value}) do\n"
            out.indent do
              out.puts "value\n"
              unless typedef.declaration.type.size.nil?
                out.puts "|> XDR.String.new(@max_length)\n"
              else
                out.puts "|> XDR.String.new()\n"
              end
              out.puts "|> XDR.String.encode_xdr()"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr!(%__MODULE__{value: value}) do\n"
            out.indent do
              out.puts "value\n"
              unless typedef.declaration.type.size.nil?
                out.puts "|> XDR.String.new(@max_length)\n"
              else
                out.puts "|> XDR.String.new()\n"
              end
              out.puts "|> XDR.String.encode_xdr!()"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr(bytes, term \\\\ nil)\n\n"

            out.puts "def decode_xdr(bytes, _term) do\n"
            out.indent do
              out.puts "case XDR.String.decode_xdr(bytes) do\n"
              out.indent do
                out.puts "{:ok, {%XDR.String{string: value}, rest}} -> {:ok, {new(value), rest}}\n"
                out.puts "error -> error\n"
              end
              out.puts "end\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr!(bytes, term \\\\ nil)\n\n"

            out.puts "def decode_xdr!(bytes, _term) do\n"
            out.indent do
              out.puts "{%XDR.String{string: value}, rest} = XDR.String.decode_xdr!(bytes)\n"
              out.puts "{new(value), rest}\n"
            end
            out.puts "end\n"
          end
        end
        out.close
      end

      def build_optional_typedef(typedef, attribute, name)
        file_name = "#{name.underscore.downcase}.ex"
        out = @output.open(file_name)

        render_define_block(out, "#{name}") do 
          out.indent do
            out.puts "alias #{@namespace}.#{attribute}\n\n"

            out.puts "@optional_spec XDR.Optional.new(#{attribute})\n\n"

            out.puts "@type #{attribute.underscore.downcase} :: #{attribute}.t() | nil\n\n"

            out.puts "@type t :: %__MODULE__{#{attribute.underscore.downcase}: #{attribute.underscore.downcase}()}\n\n"

            out.puts "defstruct [:#{attribute.underscore.downcase}]\n\n"


            out.puts "@spec new(#{attribute.underscore.downcase} :: #{attribute.underscore.downcase}()) :: t()\n"
            out.puts "def new(#{attribute.underscore.downcase} \\\\ nil), do: %__MODULE__{#{attribute.underscore.downcase}: #{attribute.underscore.downcase}}\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr(%__MODULE__{#{attribute.underscore.downcase}: #{attribute.underscore.downcase}}) do\n"
            out.indent do
              out.puts "#{attribute.underscore.downcase}"
              out.puts "|> XDR.Optional.new()"
              out.puts "|> XDR.Optional.encode_xdr()"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr!(%__MODULE__{#{attribute.underscore.downcase}: #{attribute.underscore.downcase}}) do\n"
            out.indent do
              out.puts "#{attribute.underscore.downcase}"
              out.puts "|> XDR.Optional.new()"
              out.puts "|> XDR.Optional.encode_xdr!()"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr(bytes, optional_spec \\\\ @optional_spec)\n\n"

            out.puts "def decode_xdr(bytes, optional_spec) do\n"
            out.indent do
              out.puts "case XDR.Optional.decode_xdr(bytes, optional_spec) do\n"
              out.indent do
                out.puts "{:ok, {%XDR.Optional{type: #{attribute.underscore.downcase}}, rest}} -> {:ok, {new(#{attribute.underscore.downcase}), rest}}\n"
                out.puts "{:ok, {nil, rest}} -> {:ok, {new(), rest}}"
                out.puts "error -> error\n"
              end
              out.puts "end\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr!(bytes, optional_spec \\\\ @optional_spec)\n\n"

            out.puts "def decode_xdr!(bytes, optional_spec) do\n"
            out.indent do
              out.puts "case XDR.Optional.decode_xdr!(bytes, optional_spec) do\n"
                out.indent do
                  out.puts "{%XDR.Optional{type: #{attribute.underscore.downcase}}, rest} -> {new(#{attribute.underscore.downcase}), rest}\n"
                  out.puts "{nil, rest} -> {new(), rest}"
                end
                out.puts "end\n"
              end
              out.puts "end\n\n"
          end
        end
        out.close
      end

      def build_opaque_typedef(typedef, type, xdr_module, size = nil, is_struct)
        size = get_size(size) unless size.nil?
        name = "#{type}#{size}"

        unless size.nil?
          file_name = "#{type.underscore.downcase}#{size}.ex"
          begin
            out = @output.open(file_name)
            render_define_block(out, name) do 
              out.indent do
                out.puts "@type t :: %__MODULE__{opaque: binary()}\n\n"
  
                out.puts "defstruct [:opaque]\n\n"
  
                out.puts "@#{type.downcase == "opaque" ? "length" : "max_size"} #{size}\n\n"
  
                out.puts "@opaque_spec XDR.#{xdr_module}.new(nil, @#{type.downcase == "opaque" ? "length" : "max_size"})\n\n"
  
                out.puts "@spec new(opaque :: binary()) :: t()\n"
                out.puts "def new(opaque), do: %__MODULE__{opaque: opaque}\n\n"
  
                out.puts "@impl true"
                out.puts "def encode_xdr(%__MODULE__{opaque: opaque}) do\n"
                out.indent do
                  out.puts "XDR.#{xdr_module}.encode_xdr(%XDR.#{xdr_module}{opaque: opaque, #{type.downcase == "opaque" ? "length: @length" : "max_size: @max_size"}})\n"
                end
                out.puts "end\n\n"
  
                out.puts "@impl true"
                out.puts "def encode_xdr!(%__MODULE__{opaque: opaque}) do\n"
                out.indent do
                  out.puts "XDR.#{xdr_module}.encode_xdr!(%XDR.#{xdr_module}{opaque: opaque, #{type.downcase == "opaque" ? "length: @length" : "max_size: @max_size"}})\n"
                end
                out.puts "end\n\n"
  
                out.puts "@impl true"
                out.puts "def decode_xdr(bytes, spec \\\\ @opaque_spec)\n\n"
  
                out.puts "def decode_xdr(bytes, spec) do\n"
                out.indent do
                  out.puts "case XDR.#{xdr_module}.decode_xdr(bytes, spec) do\n"
                  out.indent do
                    out.puts "{:ok, {%XDR.#{xdr_module}{opaque: opaque}, rest}} -> {:ok, {new(opaque), rest}}\n"
                    out.puts "error -> error\n"
                  end
                  out.puts "end\n"
                end
                out.puts "end\n\n"
  
                out.puts "@impl true"
                out.puts "def decode_xdr!(bytes, spec \\\\ @opaque_spec)\n\n"
  
                out.puts "def decode_xdr!(bytes, spec) do\n"
                out.indent do
                  out.puts "{%XDR.#{xdr_module}{opaque: opaque}, rest} = XDR.#{xdr_module}.decode_xdr!(bytes, spec)\n"
                  out.puts "{new(opaque), rest}\n"
                end
                out.puts "end\n"
              end
            end
            out.close
          rescue => exception
          end
        end

        unless is_struct
          file_name_main = "#{typedef.name.underscore.downcase}.ex"
          out_main = @output.open(file_name_main)
          render_define_block(out_main, typedef.name) do
            out_main.indent do
              out_main.puts "alias #{@namespace}.#{type}#{size}\n\n"
  
              out_main.puts "@type t :: %__MODULE__{value: binary()}\n\n"
  
              out_main.puts "defstruct [:value]\n\n"
  
              out_main.puts "@spec new(value :: binary()) :: t()\n"
              out_main.puts "def new(value), do: %__MODULE__{value: value}\n\n"
  
              out_main.puts "@impl true"
              out_main.puts "def encode_xdr(%__MODULE__{value: value}) do\n"
              out_main.indent do
                out_main.puts "value\n"
                out_main.puts "|> #{type}#{size}.new()\n"
                out_main.puts "|> #{type}#{size}.encode_xdr()\n"
              end
              out_main.puts "end\n\n"
  
              out_main.puts "@impl true"
              out_main.puts "def encode_xdr!(%__MODULE__{value: value}) do\n"
              out_main.indent do
                out_main.puts "value\n"
                out_main.puts "|> #{type}#{size}.new()\n"
                out_main.puts "|> #{type}#{size}.encode_xdr!()\n"
              end
              out_main.puts "end\n\n"
  
              out_main.puts "@impl true"
              out_main.puts "def decode_xdr(bytes, term \\\\ nil)\n\n"
  
              out_main.puts "def decode_xdr(bytes, _term) do\n"
              out_main.indent do
                out_main.puts "case #{type}#{size}.decode_xdr(bytes) do\n"
                out_main.indent do
                  out_main.puts "{:ok, {%#{type}#{size}{opaque: value}, rest}} -> {:ok, {new(value), rest}}\n"
                  out_main.puts "error -> error\n"
                end
                out_main.puts "end\n"
              end
              out_main.puts "end\n\n"
  
              out_main.puts "@impl true"
              out_main.puts "def decode_xdr!(bytes, term \\\\ nil)\n\n"
  
              out_main.puts "def decode_xdr!(bytes, _term) do\n"
              out_main.indent do
                out_main.puts "{%#{type}#{size}{opaque: value}, rest} = #{type}#{size}.decode_xdr!(bytes)\n"
                out_main.puts "{new(value), rest}\n"
              end
              out_main.puts "end\n"
            end
          end
          out_main.close
        end
      end

      def build_list_typedef(module_name, base_type, list_type, type)
        file_name = "#{module_name.underscore.downcase}.ex"
        out = @output.open(file_name)

        is_named, size = type.array_size
        if type.sub_type == :var_array
          size = get_size(size, is_named, true)
          length_nil = type.decl.resolved_size.nil?
        else
          size = get_size(size, is_named)
          length_nil = false
        end

        render_define_block(out, module_name) do
          out.indent do
            out.puts "alias #{@namespace}.#{base_type}\n\n"

            unless length_nil
              out.puts "@#{list_type.downcase == "fixedarray" ? "length" : "max_length"} #{size}\n\n"
            end

            out.puts "@array_type #{base_type}\n\n"

            out.puts "@array_spec %{type: @array_type#{length_nil ? "" : ", #{list_type.downcase == "fixedarray"? "length: @length" : "max_length: @max_length"}"}}\n\n"

            out.puts "@type t :: %__MODULE__{items: list(#{base_type}.t())}\n\n"

            out.puts "defstruct [:items]\n\n"

            out.puts "@spec new(items :: list(#{base_type}.t())) :: t()\n"
            out.puts "def new(items), do: %__MODULE__{items: items}\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr(%__MODULE__{items: items}) do\n"
            out.indent do
              out.puts "items\n"
              out.puts "|> XDR.#{list_type}.new(@array_type#{length_nil ? "" : ", @#{list_type.downcase == "fixedarray" ? "length" : "max_length"}"})\n"
              out.puts "|> XDR.#{list_type}.encode_xdr()\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def encode_xdr!(%__MODULE__{items: items}) do\n"
            out.indent do
              out.puts "items\n"
              out.puts "|> XDR.#{list_type}.new(@array_type#{length_nil ? "" : ", @#{list_type.downcase == "fixedarray" ? "length" : "max_length"}"})\n"
              out.puts "|> XDR.#{list_type}.encode_xdr!()\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr(bytes, spec \\\\ @array_spec)\n\n"

            out.puts "def decode_xdr(bytes, spec) do\n"
            out.indent do
              out.puts "case XDR.#{list_type}.decode_xdr(bytes, spec) do\n"
              out.indent do
                out.puts "{:ok, {items, rest}} -> {:ok, {new(items), rest}}\n"
                out.puts "error -> error\n"
              end
              out.puts "end\n"
            end
            out.puts "end\n\n"

            out.puts "@impl true"
            out.puts "def decode_xdr!(bytes, spec \\\\ @array_spec)\n\n"

            out.puts "def decode_xdr!(bytes, spec) do\n"
            out.indent do
              out.puts "{items, rest} = XDR.#{list_type}.decode_xdr!(bytes, spec)\n"
              out.puts "{new(items), rest}\n"
            end
            out.puts "end\n"
          end
        end
        out.close
      end

      def build_typedef(typedef, is_struct)
        type = typedef.declaration.type
        base_type = type_string(type)
        name = typedef.name

        case type.sub_type
          when :optional
            build_optional_typedef(typedef, base_type, name)
          when :array
            build_list_typedef(name, base_type, "FixedArray", type)
          when :var_array
            build_list_typedef(name, base_type, "VariableArray", type)
          else
          case type
            when AST::Typespecs::Bool
              build_bool_typedef(typedef, "boolean", "Bool", "bool")
            when AST::Typespecs::Double
              build_number_typedef(typedef, "float_number", "DoubleFloat", "float")
            when AST::Typespecs::Float
              build_number_typedef(typedef, "float_number", "Float", "float")
            when AST::Typespecs::Hyper
              build_number_typedef(typedef, "integer", "HyperInt", "datum")
            when AST::Typespecs::Int
              build_number_typedef(typedef, "integer", "Int", "datum")
            when AST::Typespecs::Opaque
              if type.fixed?
                build_opaque_typedef(typedef, "Opaque", "FixedOpaque", type.size, is_struct)
              else
                type.size ? build_opaque_typedef(typedef, "VariableOpaque", "VariableOpaque", type.size, is_struct) : build_opaque_typedef(typedef, "VariableOpaque", "VariableOpaque", is_struct)
              end
            when AST::Typespecs::Quadruple
              raise "no quadruple support in elixir"
            when AST::Typespecs::String
              build_string_typedef(typedef, is_struct)
            when AST::Typespecs::UnsignedHyper
              build_number_typedef(typedef, "non_neg_integer", "HyperUInt", "datum")
            when AST::Typespecs::UnsignedInt
              build_number_typedef(typedef, "non_neg_integer", "UInt", "datum")
            else
              build_simple_typedef(typedef, base_type, typedef.name, is_struct)
          end
        end
      end

      def name(named)
        parent = name named.parent_defn if named.is_a?(AST::Concerns::NestedDefinition)
        result = named.name.camelize
        "#{parent}#{result}"
      end
    end
  end
end
